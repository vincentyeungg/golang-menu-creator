// Code generated by sqlc. DO NOT EDIT.
// source: menuItem_ingredient.sql

package db

import (
	"context"
	"time"
)

const createMenuItemIngredient = `-- name: CreateMenuItemIngredient :one
INSERT INTO "MenuItem_Ingredient" (
    food_id, ingredient_id, status 
)
VALUES ( 
    $1, $2, $3 
)
RETURNING id, food_id, ingredient_id, created_at, created_by, updated_at, updated_by, status
`

type CreateMenuItemIngredientParams struct {
	FoodID       int32  `json:"food_id"`
	IngredientID int32  `json:"ingredient_id"`
	Status       string `json:"status"`
}

func (q *Queries) CreateMenuItemIngredient(ctx context.Context, arg CreateMenuItemIngredientParams) (MenuItemIngredient, error) {
	row := q.db.QueryRowContext(ctx, createMenuItemIngredient, arg.FoodID, arg.IngredientID, arg.Status)
	var i MenuItemIngredient
	err := row.Scan(
		&i.ID,
		&i.FoodID,
		&i.IngredientID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
	)
	return i, err
}

const deleteIngredientFromItem = `-- name: DeleteIngredientFromItem :exec
DELETE FROM "MenuItem_Ingredient" 
WHERE food_id = $1 AND ingredient_id = $2
`

type DeleteIngredientFromItemParams struct {
	FoodID       int32 `json:"food_id"`
	IngredientID int32 `json:"ingredient_id"`
}

func (q *Queries) DeleteIngredientFromItem(ctx context.Context, arg DeleteIngredientFromItemParams) error {
	_, err := q.db.ExecContext(ctx, deleteIngredientFromItem, arg.FoodID, arg.IngredientID)
	return err
}

const getActiveIngredientFromMenu = `-- name: GetActiveIngredientFromMenu :one
SELECT mii.id, food_id, ingredient_id, mii.created_at, mii.created_by, mii.updated_at, mii.updated_by, mii.status, i.id, name, brand_name, description, i.created_at, i.created_by, i.updated_at, i.updated_by, i.status 
FROM "MenuItem_Ingredient" AS "mii"
JOIN "Ingredient" AS "i" ON "mii".ingredient_id = "i".id
WHERE food_id = $1 
ORDER BY "i".name 
LIMIT $2 
OFFSET $3
`

type GetActiveIngredientFromMenuParams struct {
	FoodID int32 `json:"food_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetActiveIngredientFromMenuRow struct {
	ID           int32     `json:"id"`
	FoodID       int32     `json:"food_id"`
	IngredientID int32     `json:"ingredient_id"`
	CreatedAt    time.Time `json:"created_at"`
	CreatedBy    string    `json:"created_by"`
	UpdatedAt    time.Time `json:"updated_at"`
	UpdatedBy    string    `json:"updated_by"`
	Status       string    `json:"status"`
	ID_2         int32     `json:"id_2"`
	Name         string    `json:"name"`
	BrandName    string    `json:"brand_name"`
	Description  string    `json:"description"`
	CreatedAt_2  time.Time `json:"created_at_2"`
	CreatedBy_2  string    `json:"created_by_2"`
	UpdatedAt_2  time.Time `json:"updated_at_2"`
	UpdatedBy_2  string    `json:"updated_by_2"`
	Status_2     string    `json:"status_2"`
}

func (q *Queries) GetActiveIngredientFromMenu(ctx context.Context, arg GetActiveIngredientFromMenuParams) (GetActiveIngredientFromMenuRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveIngredientFromMenu, arg.FoodID, arg.Limit, arg.Offset)
	var i GetActiveIngredientFromMenuRow
	err := row.Scan(
		&i.ID,
		&i.FoodID,
		&i.IngredientID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.Status,
		&i.ID_2,
		&i.Name,
		&i.BrandName,
		&i.Description,
		&i.CreatedAt_2,
		&i.CreatedBy_2,
		&i.UpdatedAt_2,
		&i.UpdatedBy_2,
		&i.Status_2,
	)
	return i, err
}

const getAllActiveIngredientsFromMenu = `-- name: GetAllActiveIngredientsFromMenu :many
SELECT mii.id, food_id, ingredient_id, mii.created_at, mii.created_by, mii.updated_at, mii.updated_by, mii.status, i.id, name, brand_name, description, i.created_at, i.created_by, i.updated_at, i.updated_by, i.status 
FROM "MenuItem_Ingredient" AS "mii"
JOIN "Ingredient" AS "i" ON "mii".ingredient_id = "i".id
WHERE food_id = $1 
ORDER BY "i".name 
LIMIT $2 
OFFSET $3
`

type GetAllActiveIngredientsFromMenuParams struct {
	FoodID int32 `json:"food_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllActiveIngredientsFromMenuRow struct {
	ID           int32     `json:"id"`
	FoodID       int32     `json:"food_id"`
	IngredientID int32     `json:"ingredient_id"`
	CreatedAt    time.Time `json:"created_at"`
	CreatedBy    string    `json:"created_by"`
	UpdatedAt    time.Time `json:"updated_at"`
	UpdatedBy    string    `json:"updated_by"`
	Status       string    `json:"status"`
	ID_2         int32     `json:"id_2"`
	Name         string    `json:"name"`
	BrandName    string    `json:"brand_name"`
	Description  string    `json:"description"`
	CreatedAt_2  time.Time `json:"created_at_2"`
	CreatedBy_2  string    `json:"created_by_2"`
	UpdatedAt_2  time.Time `json:"updated_at_2"`
	UpdatedBy_2  string    `json:"updated_by_2"`
	Status_2     string    `json:"status_2"`
}

func (q *Queries) GetAllActiveIngredientsFromMenu(ctx context.Context, arg GetAllActiveIngredientsFromMenuParams) ([]GetAllActiveIngredientsFromMenuRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllActiveIngredientsFromMenu, arg.FoodID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllActiveIngredientsFromMenuRow{}
	for rows.Next() {
		var i GetAllActiveIngredientsFromMenuRow
		if err := rows.Scan(
			&i.ID,
			&i.FoodID,
			&i.IngredientID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.ID_2,
			&i.Name,
			&i.BrandName,
			&i.Description,
			&i.CreatedAt_2,
			&i.CreatedBy_2,
			&i.UpdatedAt_2,
			&i.UpdatedBy_2,
			&i.Status_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllIngredientsFromFood = `-- name: GetAllIngredientsFromFood :many
SELECT mii.id, food_id, ingredient_id, mii.created_at, mii.created_by, mii.updated_at, mii.updated_by, mii.status, i.id, name, brand_name, description, i.created_at, i.created_by, i.updated_at, i.updated_by, i.status 
FROM "MenuItem_Ingredient" AS "mii"
JOIN "Ingredient" AS "i" ON "mii".ingredient_id = "i".id
WHERE food_id = $1 
ORDER BY "i".name 
LIMIT $2 
OFFSET $3
`

type GetAllIngredientsFromFoodParams struct {
	FoodID int32 `json:"food_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllIngredientsFromFoodRow struct {
	ID           int32     `json:"id"`
	FoodID       int32     `json:"food_id"`
	IngredientID int32     `json:"ingredient_id"`
	CreatedAt    time.Time `json:"created_at"`
	CreatedBy    string    `json:"created_by"`
	UpdatedAt    time.Time `json:"updated_at"`
	UpdatedBy    string    `json:"updated_by"`
	Status       string    `json:"status"`
	ID_2         int32     `json:"id_2"`
	Name         string    `json:"name"`
	BrandName    string    `json:"brand_name"`
	Description  string    `json:"description"`
	CreatedAt_2  time.Time `json:"created_at_2"`
	CreatedBy_2  string    `json:"created_by_2"`
	UpdatedAt_2  time.Time `json:"updated_at_2"`
	UpdatedBy_2  string    `json:"updated_by_2"`
	Status_2     string    `json:"status_2"`
}

func (q *Queries) GetAllIngredientsFromFood(ctx context.Context, arg GetAllIngredientsFromFoodParams) ([]GetAllIngredientsFromFoodRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllIngredientsFromFood, arg.FoodID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllIngredientsFromFoodRow{}
	for rows.Next() {
		var i GetAllIngredientsFromFoodRow
		if err := rows.Scan(
			&i.ID,
			&i.FoodID,
			&i.IngredientID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.Status,
			&i.ID_2,
			&i.Name,
			&i.BrandName,
			&i.Description,
			&i.CreatedAt_2,
			&i.CreatedBy_2,
			&i.UpdatedAt_2,
			&i.UpdatedBy_2,
			&i.Status_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
